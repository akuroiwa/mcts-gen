# Develop ligand_mcts.py
## Feature Description
This feature introduces a new game module, `ligand_mcts.py`, into the `mcts-gen` framework. This module enables the generation of novel ligand molecules optimized for fitting into a specific protein binding pocket using Monte Carlo Tree Search (MCTS). The process involves iteratively building molecules guided by a scoring function that considers shape complementarity to the pocket, as well as relevant chemical properties such as hydrophobicity and druglikeness.

## User Scenarios & Testing
### Scenario 1: Initiating Ligand Generation
**Given** the user wants to generate a ligand for a specific protein pocket.
**When** the user requests to start a ligand generation simulation (e.g., via a command or prompt to the AI agent).
**Then** the AI agent provides instructions for installing necessary Python packages (`rdkit-pypi`, `scipy`, `numpy`) and the `fpocket` software (via `snap`).
**And** the AI agent prompts the user to provide the path to the protein's PDB file and the corresponding `pocketX_atm.pdb` file generated by `fpocket`.

### Scenario 2: Running MCTS for Ligand Generation
**Given** the `ligand_mcts` game module is initialized with a valid `pocketX_atm.pdb` file.
**When** the `mcts-gen` system executes MCTS rounds.
**Then** the system iteratively explores molecular structures by adding fragments.
**And** each generated (or partially generated) molecule is evaluated based on its shape complementarity to the pocket, hydrophobicity (MolLogP), and druglikeness (QED).
**And** the MCTS search is guided by this evaluation to find high-scoring molecular candidates.

### Scenario 3: Retrieving Best Generated Ligand
**Given** an MCTS simulation for ligand generation has completed a sufficient number of rounds.
**When** the user requests the best generated ligand.
**Then** the system returns the highest-scoring ligand molecule found during the search, typically as a SMILES string or a representation of the molecular structure.

## Functional Requirements
*   **FR1:** The system MUST provide a new Python module located at `src/mcts_gen/games/ligand_mcts.py`.
*   **FR2:** The `ligand_mcts.py` module MUST implement a `LigandMCTSGameState` class that inherits from `GameStateBase` (defined in `mcts_gen.models.game_state`).
*   **FR3:** The `LigandMCTSGameState` class MUST implement all abstract methods of `GameStateBase`: `getCurrentPlayer`, `getPossibleActions`, `takeAction`, `isTerminal`, and `getReward`.
*   **FR4:** The `LigandMCTSGameState` constructor MUST accept a `pocket_path` argument, specifying the path to an `fpocket`-generated `pocketX_atm.pdb` file, to initialize the pocket for evaluation.
*   **FR5:** The `getPossibleActions` method MUST return a list of `LigandAction` objects, representing chemically plausible additions of molecular fragments or atoms to the current molecular state.
*   **FR6:** The `takeAction` method MUST apply a `LigandAction` to the current molecular state and return a new `LigandMCTSGameState` instance representing the resultant molecular state.
*   **FR7:** The `getReward` method MUST calculate a score (reward) for the current molecular state using an `Evaluator` class. This reward MUST incorporate:
    *   Shape complementarity to the target protein pocket (e.g., Gaussian overlap, USR).
    *   Molecular hydrophobicity (e.g., RDKit's MolLogP).
    *   Druglikeness (e.g., RDKit's QED score).
    *   Penalties for chemically invalid or excessively large/small molecules.
*   **FR8:** The system MUST dynamically load the `ligand_mcts` module when the AI agent specifies `state_module="mcts_gen.games.ligand_mcts"` and `state_class="LigandMCTSGameState"` during MCTS initialization.
*   **FR9:** When a user initiates ligand generation, the AI agent MUST provide instructions for installing necessary Python packages (`rdkit-pypi`, `scipy`, `numpy`) via `pip` and `fpocket` via `snap` (`sudo snap install fpocket`).

## Success Criteria
*   The `mcts-gen` framework successfully initializes and runs MCTS simulations using the `ligand_mcts` module without errors.
*   The `ligand_mcts` module consistently generates chemically valid molecular structures (verified by RDKit sanitization) during MCTS simulations.
*   After running an MCTS simulation for a predefined number of iterations (e.g., 1000 rounds), the system returns a ligand candidate (SMILES string) whose `getReward` score is demonstrably higher than randomly generated molecules, indicating effective optimization towards the pocket.
*   The generated ligand candidates demonstrate a reasonable range of physicochemical properties (e.g., MolLogP between -2 and 5, QED > 0.6), suggesting consideration of druglikeness.
*   Users are clearly guided on required software installations when attempting to use the ligand generation feature for the first time, ensuring a smooth setup experience.

## Key Entities
*   **LigandMCTSGameState:** Represents the current state of the ligand generation process (i.e., the molecule being built).
*   **LigandAction:** Represents an action taken to modify the current ligand state (e.g., adding a fragment).
*   **Evaluator:** A utility class responsible for scoring a generated ligand against the protein pocket and chemical criteria.
*   **Protein Pocket:** Defined by a point cloud (`pocketX_atm.pdb`) from `fpocket`.
*   **Molecule:** The chemical structure being generated, represented internally by an RDKit Mol object.

## Assumptions
*   The `mcts-gen` framework's `AiGpSimulator` correctly handles dynamic module loading based on `state_module` and `state_class` parameters.
*   The user has Python 3.8+ installed and a working internet connection for package installations.
*   The user is able to provide a valid `pocketX_atm.pdb` file path from `fpocket`.
*   The `fpocket` tool, once installed via snap, functions correctly and generates `pocketX_atm.pdb` files with appropriate formatting.
*   The `rdkit-pypi`, `scipy`, and `numpy` packages are compatible with the user's Python environment.

## Dependencies
*   **Internal:** `mcts_gen.models.game_state` (for `GameStateBase`).
*   **External Python Libraries (Installed by user):** `rdkit-pypi`, `scipy`, `numpy`.
*   **External Software (Installed by user):** `fpocket` (via `snap`).

## Open Questions / Clarifications
None. All critical aspects have been clarified in previous discussions.