# Game Module Interface: LigandMCTSGameState

## 1. Overview
This document specifies the contract that `ligand_mcts.py` fulfills. As this is a Python game module and not a web API, the contract is defined by its adherence to the `GameStateBase` abstract base class required by the `mcts-gen` framework.

The core of the contract is the `LigandMCTSGameState` class, which is designed to be dynamically loaded and instantiated by the `AiGpSimulator` service.

## 2. Public Class: `LigandMCTSGameState`
- **Inherits from:** `mcts_gen.models.game_state.GameStateBase`
- **Purpose:** To provide a standard interface for the MCTS engine to interact with the ligand generation "game".

### `__init__`
- **Signature:** `__init__(self, pocket_path: str)`
- **Description:** The constructor is called by the `AiGpSimulator` when a new simulation is initialized. The `pocket_path` is provided via the `state_kwargs` dictionary.
- **Arguments:**
    - `pocket_path (str)`: **Required.** The file system path to the `pocketX_atm.pdb` file generated by `fpocket`. This file defines the target pocket for the simulation.

## 3. `GameStateBase` Method Implementations

### `getCurrentPlayer() -> int`
- **Description:** Returns the current player. In the context of ligand generation, which is a single-player optimization problem, this will always return a constant value of `1`.

### `getPossibleActions() -> List[LigandAction]`
- **Description:** Returns a list of all valid actions that can be taken from the current state.
- **Returns:** A list of `LigandAction` data class instances. Each instance represents the addition of a specific molecular fragment. The `LigandAction` class is serializable to allow for inspection by AI agents.

### `takeAction(action: LigandAction) -> LigandMCTSGameState`
- **Description:** Applies the given `action` to the current state's molecule and returns a *new* `LigandMCTSGameState` instance representing the resulting state.
- **Arguments:**
    - `action (LigandAction)`: The action to apply.
- **Returns:** A new `LigandMCTSGameState` object.

### `isTerminal() -> bool`
- **Description:** Determines if the current state is a terminal state (i.e., the "game" is over).
- **Returns:** `True` if the molecule has reached a maximum size threshold or if no further actions can be taken. Otherwise, returns `False`.

### `getReward() -> float`
- **Description:** If the state is terminal, this method calculates and returns the final reward for the generated molecule.
- **Returns:** A `float` value representing the quality of the final molecule, as determined by the internal `Evaluator` class. The score is based on shape complementarity, hydrophobicity (MolLogP), druglikeness (QED), and chemical validity.
