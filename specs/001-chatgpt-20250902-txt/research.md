# Research & Decisions

This document consolidates the research and key technical decisions made for the Generic MCTS Framework feature.

## 1. Policy & Prediction Handling

### Decision: Server-Side Policy Normalization
- **Rationale**: To handle cases where a client sends an invalid policy (e.g., probabilities don't sum to 1, includes illegal moves), the server will be responsible for sanitizing the input. This aligns with the AlphaZero methodology and makes the server more robust.
- **Implementation**: The server will take the client-provided policy, filter for legal moves in the current state, and re-normalize the probabilities to sum to 1.

### Decision: Dirichlet Noise for Exploration
- **Rationale**: To improve the diversity of exploration during the self-play training phase, Dirichlet noise will be added to the root node's policy distribution. This is a standard technique in AlphaZero to prevent the model from becoming too deterministic early in its training.
- **Implementation**: The noise will only be applied during self-play mode, not during standard "best move" searches.

### Decision: Fallback to MCTS Rollout
- **Rationale**: If the AI model cannot provide a policy/value prediction for a given state, the system should not fail. It will gracefully degrade.
- **Implementation**: The MCTS engine will detect the absence of an AI prediction and fall back to a standard, random MCTS rollout (simulation phase) to estimate the node's value.

## 2. Architecture & API

### Decision: Dual Architecture Support
- **Rationale**: The system needs to be flexible for different use cases. A simple local script is sufficient for some simulations, while a client-server model is necessary for web integration or standardized interfaces.
- **Implementation**: The core MCTS logic will be implemented as a standalone library. A separate Web API layer (using FastAPI) will wrap this library to provide a client-server model. This allows users to either import the library directly (local model) or interact with the API (client-server model).

### Decision: Configurable API Authentication
- **Rationale**: The Web API needs a flexible access control mechanism.
- **Implementation**: Authentication will be a configurable option on the server. It can be enabled or disabled. When enabled, it will use a simple, shareable API key for authorization. This provides a balance between security and ease of use for the initial version.

### Decision: API Disconnection Handling
- **Rationale**: The API server should be resilient to client disconnections.
- **Implementation**: When operating in the client-server model, if a client stops sending prediction requests, the server will automatically switch to the MCTS rollout fallback mechanism to continue the search.

## 3. Code Generation & Dependencies

### Decision: Self-Contained Code Generation
- **Rationale**: To avoid dependency issues on the user's machine, the code generated by the AI agent should be as self-contained as possible.
- **Implementation**: When the AI generates a `*_mcts.py` file, it will include a copy of the `GameStateBase` abstract class directly in the file. This removes the need for the user to have a specific package pre-installed.

### Decision: Refined AlphaZero Policy
- **Rationale**: The user requested the policy implementation to be closer to AlphaZero than the initial chat discussion.
- **Implementation**: The policy head of the neural network will output logits. The server/training code will apply a softmax function only over the set of legal moves for a given state to create the final probability distribution. The training target for the policy head will be the normalized visit counts from the MCTS search, as is standard in AlphaZero.
